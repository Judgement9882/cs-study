<div align=center>
<h1> 정렬 알고리즘 </h1>
</div>

> 발표일　　|　 2023.08.16 <br />
발표자　　|　박현철 <br />
> 

<div align=center>
<h3>📇 목차 </h3>
</div>

[1.]선택정렬<br />
[2.]삽입정렬<br />
[3.]버블정렬 <br />
[4.]병합정렬 <br />
5[.]퀵정렬 <br />

<br>

# 선택정렬

```
- 선택 정렬: 제자리 정렬 알고리즘의 하나로, 다음과 같은 순서로 이루어진다.

1. 주어진 리스트 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
```
![image](https://github.com/hyuntall/cs-study/assets/71054445/51880fdc-c6f6-4e56-b060-e07bbd2a0f4b)
<br>

### 의사 코드

```c
for i = 0 to n:
    a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자.
    a[i]와 a[j]의 값을 서로 맞바꾼다.
```

<br>

### 소스 코드

```java
void selectionSort(int[] list) {
    int indexMin, temp;

    for (int i = 0; i < list.length - 1; i++) {
        indexMin = i;
        for (int j = i + 1; j < list.length; j++) {
            if (list[j] < list[indexMin]) {
                indexMin = j;
            }
        }
        temp = list[indexMin];
        list[indexMin] = list[i];
        list[i] = temp;
    }
}
```

### 시간 복잡도

| O(n^2) | 최악 |
| --- | --- |
| O(n^2) | 최선 |
| O(n^2) | 평균 |

### 공간 복잡도

O(1)

### 개선 방법

**이중 선택 정렬**: **한 번의 탐색**에서 **최솟값**과 **최댓값**을 **같이** 찾는 방법이다. 탐색 횟수가 **절반**으로 줄어들게 된다.

탐색을 응용하여 개선: 한 번의 **탐색 때 동일한 값이 있다면 함께 정렬**하는 방법이다. 즉, 만약 최솟값을 찾았는데 그 값과 같은 값이 있다면 다음 번 탐색 때 최솟값으로 탐색될 것이기에 이 값도 탐색된 것으로 보고 미리 정렬한다. 같은 값이 많을수록 유용하게 된다.[[1]](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC#cite_note-1)

# 삽입정렬

```
- 삽입 정렬: 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 삽입하는 알고리즘

1. 두번째 인덱스부터 시작하여, 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스-1로 지정한다.
2. 별도로 저장해둔 변수와 비교 인덱스의 배열 값을 비교한다.
3. 저장해둔 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
4. 저장해둔 변수가 더 크면, 비교 인덱스+1에 삽입 변수를 저장한다.
```
![image](https://github.com/hyuntall/cs-study/assets/71054445/56e32bd7-355c-4aec-b5e0-c4227c6707fd)

<br>

### 소스코드

```java
void insertionSort(int[] arr)
{

   for(int index = 1 ; index < arr.length ; index++){

      int temp = arr[index];
      int aux = index - 1;

      while( (aux >= 0) && ( arr[aux] > temp ) ) {

         arr[aux + 1] = arr[aux];
         aux--;
      }
      arr[aux + 1] = temp;
   }
}
```

### 복잡도

이미 정렬되어있는 경우 O(n)

최악의 경우(역정렬 되어있을 경우) O(n^2)




# 버블 정렬

```
버블 정렬: 인접한 두 원소를 비교하고, 조건에 맞지 않으면 자리를 교환하며 정렬하는 알고리즘

1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
2. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.
```

![image](https://github.com/hyuntall/cs-study/assets/71054445/6e88e622-54f9-4cc1-964a-0b600d4bf9c6)



### 소스코드

```java
void bubbleSort(int[] arr) {
    int temp = 0;
	for(int i = 0; i < arr.length; i++) {       // 1.
		for(int j= 1 ; j < arr.length-i; j++) { // 2.
			if(arr[j-1] > arr[j]) {             // 3.
                // swap(arr[j-1], arr[j])
				temp = arr[j-1];
				arr[j-1] = arr[j];
				arr[j] = temp;
			}
		}
	}
	System.out.println(Arrays.toString(arr));
}
```

### 복잡도

시간복잡도를 계산하면, `(n-1) + (n-2) + (n-3) + .... + 2 + 1 => n(n-1)/2`이므로, **O(n^2)** 이다. 또한, Bubble Sort는 정렬이 돼있던 안돼있던, 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 **O(n^2)** 으로 동일하다. 

### 장점

- 구현이 매우 간단하고, 소스코드가 직관적이다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort) 이다.

### 단점

- 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
- 정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 된다.

### 개선된 버블 정렬

버블 정렬에서 각 단계에서 자료의 교환이 더이상 발생하지 않으면 정렬이 끝난 것을 의미하므로 다음 단계를 실행하지 않고 정렬을 종료할 수 있다. 이렇게 하면 정렬 실행 시간이 단축된다.

```java
void advanced_bubble_sort(int data[], int n) {
    int i, j;
    int temp;
    int flag = 1;    //1이면 자료 교환이 발생했음을 나타냄
 
    for (i = n - 1; flag&&i >= 1; i--) {
        flag = 0;
        for(j=0; j<i; j++)
            if (data[j] > data[j + 1]) {
                temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
                flag = 1;
            }
    }
}
```

# 퀵정렬

```
퀵 정렬: 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.

분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
```

![image](https://github.com/hyuntall/cs-study/assets/71054445/be4a0de2-bcc2-40e5-bb8d-3f760320794c)


### 장점

- 속도가 빠르다.
    - 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 추가 메모리 공간을 필요로 하지 않는다.
    - 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
    

### 단점

정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

### 복잡도

최선의 경우 O(nlogn)

최악의 경우 O(n^2), 리스트가 불균형하게 나누어지는 경우(특히 이미 정렬된 리스트에 대해 실행하는 경우)

# 병합정렬

```
	병합 정렬: 분할정복 알고리즘의 하나로, 리스트를 작은 리스트의 단위로 나누어 정렬 후 병합하는 알고리즘

1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
2. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.
```

![image](https://github.com/hyuntall/cs-study/assets/71054445/0397e083-707e-449e-9394-2b41cecced6b)


### 장점

- 안정적인 정렬
    - 데이터 분포에 영향을 덜 받는다. 즉, 어떠한 경우든 시간복잡도는 동일하다.
- 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
    - 자리 정렬(in-place sorting)로 구현할 수 있다.
- 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.

### 단점

- 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
    - 제자리 정렬(in-place sorting)이 아니다.
- 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

### 시간복잡도

모든 경우에 상관없이 O(nlogn)

### 활용 사례
https://github.com/hyuntall/42-push_swap
<br>
https://velog.io/@hyuntall/42-Seoul-Pushswap-%EA%B3%BC%EC%A0%9C-%EC%A0%95%EB%A6%AC-2
