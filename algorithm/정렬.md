<div align=center>
  <h1> 정렬 😺 </h1>
</div>

> 발표일　　|　 2023.09.05 <br />
> 발표자　　|　강준영 <br />

<div align=center>
  <h3>📇 목차 </h3>
</div>

[1. 정의](#🏭-정의)<br /> 2. O(n<sup>2</sup>)정렬<br />
[3. O(nlogn)정렬](<#🦴-O(nlogn)정렬>) <br />
[4. 하이브리드 정렬](#🍕-하이브리드-정렬) <br />
[5. 기타 정렬](#🧩-기타-정렬) <br />

<br>

# 🏭 정의

### 정렬

```
항목들을 체계적으로 정리하는 과정
```

#### 장점

- 효율적으로 검색 가능
- 일련의 항목에 대한 병합을 효율적으로 할 수 있음
- 정의된 순서로 데이터 처리 가능

<br>

# 🌊 O(n<sup>2</sup>)정렬

### 버블 정렬

- 1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, ..., n-1번째와 n번째를 정렬한 뒤 다시 돌아가서 1번째와 2번째 원소를 비교 ..., n-2번째와 n-1번째를 비교.... 반복..

- 최선의 경우 0번 정렬 (이미 정렬된 경우) (이 경우 시간복잡도는 탐색에 필요한 O(n))
- 최악의 경우 n(n-1)/2 번 정렬

- 효율 매우 안좋음. 전혀 안쓰임

```C
void Bubble_Sort(int arr[], int len) {
  int i, j, tmp;
  for (i = 0; i < len - 1; ++i) {
    for (j = 0; j < len - i - 1; ++j) {
      if (arr[j] > arr[j + 1]) {
        tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
      }
    }
  }
}
```

### 선택 정렬

- 1번째부터 n까지 쭉 확인해서 가장 작은 수를 찾고 1번째 수로, 2번째부터 n까지 쭉 확인해서 가장 작은 수를 찾고 2번째 수로... 반복

- 최선의 경우(정렬된 경우)에도 매번 비교하기 때문에 똑같이 O(n<sup>2</sup>)

- 최악의 경우에도 O(n<sup>2</sup>)

```C
void selectionSort(int arr[], int n) {
    int i, j, minIndex, tmp;

    for (i = 0; i < n - 1; i++) {
        minIndex = i;
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        tmp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = tmp;
    }
}
```

### 삽입 정렬

- k번째 원소를 1부터 k-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식

- 평균적으로는 O(n<sup>2</sup>) 방식중 빠른편

- 최선의 경우 (이미 정렬됨) O(n) (바로 다음 항목과 비교했을때 이미 조건을 만족하므로)

- 최악의 경우 O(n<sup>2</sup>)
- 자료구조에 따라 뒤로 밀어내는데 시간이 오래걸릴 수 있음

- 탐색을 제외한 오버헤드가 매우 적기 때문에 최선의 경우 가장 효율적인 알고리즘.
- 배열이 작을 경우에도 효율적. 일반적으로 빠르다고 알려진 알고리즘들도 배열이 작을 경우 대부분 삽입정렬에 밀림 -> 고성능 알고리즘 중에서는 배열의 사이즈가 클때는 O(nlogn) 알고리즘 쓰다가 작아지면 삽입 정렬로 전환하는 알고리즘도 있음

```C
void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        // key보다 큰 원소를 오른쪽으로 이동
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
```

# 🦴 O(nlogn)정렬

### 병합 정렬(합병 정렬)

- 원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개서 자른 순서의 역순으로 크기를 비교해 병합하는 정렬

- 병합된 부분 안은 이미 정렬되어 있으므로 전부 비교하지 않아도 제자리를 찾을 수 있음

- 성능은 퀵 정렬보다 떨어짐

- 데이터 크기와 동일한 메모리 필요

- 정렬되어 있는 두 배열을 합칠 때 병합정렬의 마지막 단계를 사용한다면 가장 빠르게 정렬된 상태로 합칠 수 있음

### 힙 정렬

- 힙 자료구조를 이용한 방법

1. 원소들을 전부 힙에 삽입
2. 힙의 루트에 있는 값은 남은 수 들 중에서 최소 or 최댓값이므로 루트를 출력하고 힙에서 제거
3. 힙이 빌 때 까지 2의 과정 반복

- 추가 메모리 필요 x

- 항상 O(nlogn) 의 시간복잡도.

### 퀵 정렬

- 적절한 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬

- 최선의 경우 O(nlogn)

- 최악의 경우 O(n<sup>2</sup>)
  - 이미 정렬된 배열 : pivot을 처음이나 마지막 원소로 선택하면 분할 결과가 항상 한쪽에 치우치게됨 -> 분할을 못함
  - 모든 원소값이 같은 배열 : pivot을 어떠한 값을 선택하더라도 항상 분할 결과가 한쪽으로 치우쳐짐
  - 매번 최솟값 or 최댓값을 pivot으로 선택하는 경우 -> 항상 한쪽으로 치우쳐짐
- 이를 방지하기 위해 random quick sort (pivot을 랜덤으로 잡음) 방법도 있음. 다만 이 경우도 운 나쁘면 성능 안좋음.

- 항상 O(nlogn)인 힙 정렬보다 느릴 것 같지만 일반적으로 빠르게 동작 => 퀵 정렬의 경우는 대개 원소들끼리 근접한 메모리 영역에 붙어 있는 배열을 사용하기 때문에 일반적으로 캐시 친화적이지만 힙정렬의 원소들은 좀 더 흩어져 있는 경우가 많아서 캐시 친화도가 떨어지는 문제가 있다. 또한 힙정렬은 일반적으로 포인터 연산을 많이 사용하기 때문에 거기에 걸리는 오버헤드도 무시할 수는 없는 수준

# 🍕 하이브리드 정렬

### 팀소트

- 병합 + 삽입 정렬

- 병합 정렬은 원소의 개수가 적을 때 오버헤드가 발생하기 때문에 파티션 크기가 특정 값 이하(보통 16 또는 32)가 되면 삽입 정렬을 사용

- Java Collections의 공식 정렬 알고리즘

- 일종의 병합정렬이므로 추가 메모리 필요

### 인트로 정렬(Intro sort)

- 퀵 + 힙 정렬

- 기본적으로 퀵 정렬을 하지만 재귀 깊이가 깊어지는 경우 힙 정렬을 사용

- C++의 std::sort()에서 가장 널리 쓰이는 정렬 방법. C#에서도 사용

# 🧩 기타 정렬

특정한 상황에서는 O(n log n) 보다 더 빠른 O(n)으로 정렬을 실행할 수 있음

### 기수 정렬(Radix sort)

- 시간복잡도 : O(kn) (k는 데이터의 자릿수)

- 자릿수가 있는 데이터(정수, 문자열 등)에서만 수행이 가능

- 데이터끼리의 직접적인 비교 없이 정렬을 수행

- but 자릿수가 적은 4바이트 정수 등에서나 제대로 된 성능을 발휘

- 자릿수가 무제한에 가까운 문자열 정렬 등에 사용할 경우 오히려 퀵정렬보다 느릴 수 있고, 부동 소수점의 경우는 부호여부, 지수부, 가수부에 대해 각각 기수정렬을 실행해야 함

```
방법 :
데이터가 x진법이라고 가정. 0번부터 x-1번까지의 리스트를 만들어 놓고, 각 데이터를 순서대로 현재 자릿수의 숫자가 가리키는 리스트에 밀어넣고, 리스트를 0번부터 x-1번까지 순서대로 이어붙인다. 이 과정을 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복하면 정렬 종료.

예시 :

10진법 수 : 10, 5, 15, 234, 1
최대 3자리 수인 정수.
편의상 010, 005, 015, 234, 001로 표기.

100의 자리: 0) 010, 1) 001, 4) 234, 5) 005, 015.
순서대로 이어붙이면 010, 001, 234, 005, 015.
101의 자리: 0) 001, 005, 1) 010, 015, 3) 234.
순서대로 이어붙이면 001, 005, 010, 015, 234.
102의 자리: 0) 001, 005, 010, 015, 2) 234.
순서대로 이어붙이면 001, 005, 010, 015, 234.
=> 1 5 10 15 234

```

### 카운팅 정렬(Counting sort)

- 시간복잡도 : O(n+k) (k는 count array의 길이)

- 특정 데이터의 개수(1이 두 개 있다면 2)를 데이터의 값에 대응하는 위치에 저장한 뒤, 자신의 위치에서 앞에 있던 값을 모두 더한 배열을 만든 뒤, 거기서 데이터가 들어가야 할 위치를 찾아내는 정렬 알고리즘

- k가 작다는 조건이라면 매우 효율적인 정렬 (데이터는 정수라는 전제를 깔아야함)

```
예시 :

input : [3, 0, 5, 1, 0, 5] 오름차순 정렬

1. 최댓값 최솟값 구하기 -> 5, 0 => count 배열의 크기는 6

2. 각 숫자의 개수를 세어서 count 배열에 반영

count[0] = 2
count[1] = 1
count[2] = 0
count[3] = 1
count[4] = 0
count[5] = 2

3. 각 숫자가 몇 번째 인덱스에서 끝나는지 알기 위해 누적 어레이 만들기

acc_count[0] = 2
acc_count[1] = 3
acc_count[2] = 3
acc_count[3] = 4
acc_count[4] = 4
acc_count[5] = 6

4. 배열은 0-indexed이기 때문에 1을 빼줘야함

acc_count[0] = 1
acc_count[1] = 2
acc_count[2] = 2
acc_count[3] = 3
acc_count[4] = 3
acc_count[5] = 5

=> 각 숫자가 차지하는 가장 끝의 인덱스.

5. input 의 뒤에서부터 하나씩 찾아감

[3, 0, 5, 1, 0, 5] 에서

  1) 5는 acc_count에서 5를 가리킴 따라서
  sorted[5] = 5
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[5] = 5-1 = 4

  2) 0은 acc_count에서 1을 가리킴 따라서
  sorted[1] = 0
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[0] = 1-1 = 0

  3) 1은 acc_count에서 2를 가리킴 따라서
  sorted[2] = 1
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[1] = 2-1 = 1

  4) 5는 acc_count에서 4를 가리킴 따라서
  sorted[4] = 5
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[5] = 4-1 = 3

  5) 0은 acc_count에서 0을 가리킴 따라서
  sorted[0] = 0
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[0] = 0-1 = -1

  6) 3은 acc_count에서 3을 가리킴 따라서
  sorted[3] = 3
  이후 사용했으므로 누적 어레이의 값을 1 빼줌
  acc_count[3] = 3-1 = 2

sorted를 정리하면
sorted[0] = 0
sorted[1] = 0
sorted[2] = 1
sorted[3] = 3
sorted[4] = 5
sorted[5] = 5

정렬이 되었음.

정리 :
각 숫자가 몇개 있는지 알기위해 O(n) 소요
count, acc_count 배열을 만들고 -1을 하는데 O(k) 소요
최종 sorted 배열을 만드는 것에 O(n) 소요

=> O(n+k)
```

#### 출처

1. 정렬 : https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC
2. 정렬 알고리즘 : https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#s-4.1.1
3. 카운팅 정렬 : https://www.youtube.com/watch?v=Urmb0FpW6Hk
