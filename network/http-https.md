# Http vs Https
## Http(Hyper Tranfer Protocol)
인터넷에서 데이터를 주고 받는 데 사용되는 TCP/IP 프로토콜

- 브라우저와 웹 서버 간 정보를 요청(request)하고 응답(response)하는 기본 프로토콜
- 주로 HTML 문서, 이미지, 동영상 등을 전송
- 일반적으로 요청의 주체를 `client`, 응답의 주체를 `server` 라고 함

<br/><br/>

### 특징
**무상태성(Stateless)** 
- client가 server에 같은 Request를 보내도 기존의 Response 및 상태 정보가 서버에 저장 되지 않음(서버는 클라이언트의 상태를 유지하지 않음)
- 즉, 각 클라이언트에 맞게 리소스를 응답하는 것은 불가능
- 이를 해결하기 위해 쿠키나 세션, 또는 토큰 방식의 OAuth, JWT가 사용됨

<br/><br/>

### Method
client가 server에 요청방법을 정의한 것으로 주어진 리소스에 수행하길 원하는 행동을 나타냄
- **GET** : 서버에게 조회할 리소스를 요청(READ, 조회)
- **POST** :  본문(body)에 생성할 데이터를 삽입해 서버로 전송(CREATE, 생성)
- **PUT** : 본문에 수정할 데이터를 삽입해 서버로 전송(UPDATE, 수정)
- **DELETE** : 서버에게 삭제할 리소스를 요청(DELETE, 삭제)
- **PATCH** : PUT과 비슷하지만 일부만 수정한다는 점에서 다름

<br/><br/>

### 응답 상태코드
서버가 클라이언트에게 요청을 받으면 응답상태에 따라서 다른 상태코드를 클라이언트에게 돌려줌

- **1xx(요청에 대한 정보)** : 요청을 받았으면 작업을 계속한다.
- **2xx(성공)** : 요청을 성공적으로 수행했다
    - 200(성공)
    - 201(새 리소스 작성)
    - 202(요청 접수, 아직 처리는 안함)
- **3xx(리다이렉션)** : 클라이언트가 요청을 마치기 위해 추가적인 동작을 해야 함
    - 300 : 여러개의 응답, 선택해야 함
    - 301 : 영구이동, 요청한 페이지가 영구적으로 이동됨
    - 302 : 임시이동, 현재 응답이 다른 페이지이긴 하지만 임시적임

- **4xx(클라이언트 오류)** : 클라이언트에 오류가 있다.
    - 401 : 권한 없음
    - 403 : 금지됨, 리소스에 대한 권한 없음
    - 404 : 찾을 수 없음, 서버에 없는 페이지
- **5xx(서버 오류)** : 서버에 오류가 있음
    - 500 : 내부 서버 오류
    - 501 : 요청 수행 기능 없음, 메서드 인식 불가
    - 503 : 서비스 사용 불가

<br/>

---
<br/>

## HTTPS(HyperText Transfer Protocol over TSL/SSL)
HTTP에 보안 소켓 계층인 **SSL/TLS**을 추가한 HTTP를 암호화한 프로토콜

<br/><br/>

### 필요한 개념
>**공개키(Public Key), 비밀키(Private Key)**
> - 공개키를 모두가 볼 수 있는 키
> - 비밀키 : 소유자만이 가지고 있는 키로 암/복화화에 사용됨 

>**대칭키 암호화**    
> - 서버와 클라이언트가 암호화/복호화에 동일한 비밀키를 사용하는 방식
> - 키를 공유하는데 어려움이 있으나 속도가 빠름

>**비대칭키 암호화**    
> - 서버와 클라이언트가 암호화/복호화에 각각 다른 비밀키를 사용하는 방식
> - 공개키를 통해서 암호화 하고 비밀키를 통해 복호화 한다. 
> - 공개키는 공개해도 상관없기 때문에 키 관리에 어려움이 없지만 속도가 느림

>**인증기관(Certificate Authority, CA)**    
> - 클라이언트가 접속을 요청한 서버가 의도한 서버가 맞는지 인증해주는 역할을 하는 보증된 기업들

<br/><br/>


### 동작 방식
HTTPS는 대칭키 암호화를 사용하며 다음과 같은 과정을 거침
1. 클라이언트가 서버에게 접속요청을 하면 서버는 인증기관(CA)에서 발급받은 인증서를 보낸다. 인증서에는 CA의 비밀키로 암호화된 사이트 정보와 공개키가 들어있다.
2. 클라이언트는 인증서를 받아 CA의 공개키로 복호화해 접속요청한 서버가 신뢰할만한지 검증한다.
3. 복호화가 되면 인증서가 신뢰할 만하기 때문에 데이터를 주고받을 대칭키를 생성한다.
4. 대칭키를 서버의 공개키로 암호화해 서버에게 전송한다.
5. 서버는 자신의 비밀키로 클라이언트가 보낸 대칭키를 복호화한 뒤 그 대칭키를 통해 데이터를 주고 받는다. 